; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\pwm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\Library\StdDriver\inc -I..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\Library\CMSIS\Include -I..\bsp\bus\inc -I..\bsp\devices\inc -I..\User\inc -I.\RTE\_DC_Measure -ID:\software\tools\Keil_v5\Nuvoton\NuMicro_DFP\1.3.12\Device\NANO100BN\Include -ID:\software\tools\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=530 -D_RTE_ --omf_browse=.\objects\pwm.crf ..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearCaptureIntFlag PROC
;;;424     */
;;;425    void PWM_ClearCaptureIntFlag (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  00c9              LSLS     r1,r1,#3
;;;426    {
;;;427        // disable capture interrupt flag
;;;428        pwm->CAPINTSTS = (u32Edge + 1)  << (u32ChannelNum * 8);
000002  1c52              ADDS     r2,r2,#1
000004  408a              LSLS     r2,r2,r1
000006  65c2              STR      r2,[r0,#0x5c]
;;;429    }
000008  4770              BX       lr
;;;430    
                          ENDP


                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearPeriodIntFlag PROC
;;;476     */
;;;477    void PWM_ClearPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;478    {
;;;479        // write 1 clear
;;;480        pwm->INTSTS = (PWM_INTSTS_TMINT0_Msk << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  6102              STR      r2,[r0,#0x10]
;;;481    }
000006  4770              BX       lr
;;;482    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;141     */
;;;142    uint32_t PWM_ConfigCaptureChannel (PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;143                                       uint32_t u32ChannelNum,
;;;144                                       uint32_t u32UnitTimeNsec,
;;;145                                       uint32_t u32CaptureEdge)
;;;146    {
000002  4604              MOV      r4,r0
;;;147        uint32_t i;
;;;148        uint32_t u32ClkSrc;
;;;149        uint32_t u32PWM_Clock = SystemCoreClock;
000004  4843              LDR      r0,|L3.276|
000006  b083              SUB      sp,sp,#0xc            ;146
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;150        uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;151        uint16_t u16CNR = 0xFFFF;
00000a  9000              STR      r0,[sp,#0]
00000c  4842              LDR      r0,|L3.280|
00000e  460e              MOV      r6,r1                 ;146
;;;152    
;;;153        if(pwm == PWM0)
;;;154            u32ClkSrc = (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM0_CH01_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL1_PWM0_CH01_S_Pos + (u32ChannelNum & 2));
000010  9001              STR      r0,[sp,#4]
000012  2002              MOVS     r0,#2
000014  2130              MOVS     r1,#0x30
000016  4030              ANDS     r0,r0,r6
000018  4a40              LDR      r2,|L3.284|
00001a  4081              LSLS     r1,r1,r0
00001c  2501              MOVS     r5,#1                 ;150
00001e  27ff              MOVS     r7,#0xff              ;150
000020  4b3f              LDR      r3,|L3.288|
000022  1d00              ADDS     r0,r0,#4
000024  4294              CMP      r4,r2                 ;153
000026  d101              BNE      |L3.44|
000028  695a              LDR      r2,[r3,#0x14]
00002a  e000              B        |L3.46|
                  |L3.44|
;;;155        else
;;;156            u32ClkSrc = (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM1_CH01_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL2_PWM1_CH01_S_Pos + (u32ChannelNum & 2));
00002c  699a              LDR      r2,[r3,#0x18]
                  |L3.46|
00002e  400a              ANDS     r2,r2,r1
000030  40c2              LSRS     r2,r2,r0
;;;157    
;;;158        switch (u32ClkSrc)
;;;159        {
;;;160        case 0:
;;;161            u32PWM_Clock = __HXT;
000032  483c              LDR      r0,|L3.292|
000034  d005              BEQ      |L3.66|
000036  2a01              CMP      r2,#1                 ;158
000038  d005              BEQ      |L3.70|
00003a  2a02              CMP      r2,#2                 ;158
00003c  d006              BEQ      |L3.76|
00003e  2a03              CMP      r2,#3                 ;158
000040  d104              BNE      |L3.76|
                  |L3.66|
;;;162            break;
000042  9000              STR      r0,[sp,#0]
000044  e002              B        |L3.76|
                  |L3.70|
;;;163        case 1:
;;;164            u32PWM_Clock = __LXT;
000046  2001              MOVS     r0,#1
000048  03c0              LSLS     r0,r0,#15
;;;165            break;
00004a  e7fa              B        |L3.66|
                  |L3.76|
;;;166        case 2:
;;;167            u32PWM_Clock = SystemCoreClock;
;;;168            break;
;;;169        case 3:
;;;170            u32PWM_Clock = __HIRC12M;
;;;171            break;
;;;172        }
;;;173    
;;;174        for(; u8Divider < 17; u8Divider <<= 1)    // clk divider could only be 1, 2, 4, 8, 16
;;;175        {
;;;176            i = ((long long)(u32PWM_Clock / u8Divider) * u32UnitTimeNsec) / 1000000000;
00004c  4629              MOV      r1,r5
00004e  9800              LDR      r0,[sp,#0]
000050  f7fffffe          BL       __aeabi_uidivmod
000054  9905              LDR      r1,[sp,#0x14]
000056  f7fffffe          BL       __ARM_common_ll_muluu
00005a  4a33              LDR      r2,|L3.296|
00005c  2300              MOVS     r3,#0
00005e  f7fffffe          BL       __aeabi_ldivmod
;;;177    
;;;178            // If target value is larger than 0xFF, need to use a larger divider
;;;179            if(i > (0xFF))
000062  28ff              CMP      r0,#0xff
000064  d804              BHI      |L3.112|
;;;180                continue;
;;;181    
;;;182            u8Prescale = i;
000066  b2c7              UXTB     r7,r0
;;;183    
;;;184            // u8Prescale must at least be 2, otherwise the output stop
;;;185            if(u8Prescale < 3)
000068  2f03              CMP      r7,#3
00006a  d205              BCS      |L3.120|
;;;186                u8Prescale = 2;
00006c  2702              MOVS     r7,#2
00006e  e003              B        |L3.120|
                  |L3.112|
000070  0668              LSLS     r0,r5,#25             ;174
000072  0e05              LSRS     r5,r0,#24             ;174
000074  2d11              CMP      r5,#0x11              ;174
000076  d3e9              BCC      |L3.76|
                  |L3.120|
;;;187    
;;;188            break;
;;;189        }
;;;190    
;;;191        // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;192        i = (long long) (u8Prescale * u8Divider) * 1000000000 / u32PWM_Clock;
000078  4638              MOV      r0,r7
00007a  4368              MULS     r0,r5,r0
00007c  492a              LDR      r1,|L3.296|
00007e  f7fffffe          BL       __ARM_common_ll_mulss
000082  2300              MOVS     r3,#0
000084  9a00              LDR      r2,[sp,#0]
000086  f7fffffe          BL       __aeabi_ldivmod
00008a  4684              MOV      r12,r0
;;;193    
;;;194        u8Prescale -= 1;
;;;195        u16CNR -= 1;
00008c  9801              LDR      r0,[sp,#4]
00008e  1e7f              SUBS     r7,r7,#1              ;192
000090  1e40              SUBS     r0,r0,#1
000092  b2fa              UXTB     r2,r7                 ;194
000094  b287              UXTH     r7,r0
;;;196        // convert to real register value
;;;197        if(u8Divider == 1)
000096  2d01              CMP      r5,#1
000098  d033              BEQ      |L3.258|
;;;198            u8Divider = 4;
;;;199        else if (u8Divider == 2)
00009a  2d02              CMP      r5,#2
00009c  d033              BEQ      |L3.262|
;;;200            u8Divider = 0;
;;;201        else if (u8Divider == 4)
00009e  2d04              CMP      r5,#4
0000a0  d033              BEQ      |L3.266|
;;;202            u8Divider = 1;
;;;203        else if (u8Divider == 8)
0000a2  2d08              CMP      r5,#8
0000a4  d033              BEQ      |L3.270|
;;;204            u8Divider = 2;
;;;205        else // 16
;;;206            u8Divider = 3;
0000a6  2003              MOVS     r0,#3
                  |L3.168|
;;;207    
;;;208        // every two channels share a prescaler
;;;209        while((pwm->INTSTS & PWM_INTSTS_PRESSYNC_Msk ) == PWM_INTSTS_PRESSYNC_Msk);
0000a8  6921              LDR      r1,[r4,#0x10]
0000aa  05c9              LSLS     r1,r1,#23
0000ac  d4fc              BMI      |L3.168|
;;;210        pwm->PRES = (pwm->PRES & ~(PWM_PRES_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
0000ae  6823              LDR      r3,[r4,#0]
0000b0  0871              LSRS     r1,r6,#1
0000b2  00c9              LSLS     r1,r1,#3
0000b4  25ff              MOVS     r5,#0xff
0000b6  408d              LSLS     r5,r5,r1
0000b8  43ab              BICS     r3,r3,r5
0000ba  408a              LSLS     r2,r2,r1
0000bc  4313              ORRS     r3,r3,r2
0000be  6023              STR      r3,[r4,#0]
;;;211        pwm->CLKSEL = (pwm->CLKSEL & ~(PWM_CLKSEL_CLKSEL0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
0000c0  6862              LDR      r2,[r4,#4]
0000c2  00b1              LSLS     r1,r6,#2
0000c4  2307              MOVS     r3,#7
0000c6  408b              LSLS     r3,r3,r1
0000c8  439a              BICS     r2,r2,r3
0000ca  4088              LSLS     r0,r0,r1
0000cc  4302              ORRS     r2,r2,r0
0000ce  6062              STR      r2,[r4,#4]
;;;212        pwm->CTL |= (PWM_CTL_CH0MOD_Msk << (u32ChannelNum * 8));
0000d0  68a0              LDR      r0,[r4,#8]
0000d2  00f2              LSLS     r2,r6,#3
0000d4  2108              MOVS     r1,#8
0000d6  4091              LSLS     r1,r1,r2
0000d8  4308              ORRS     r0,r0,r1
0000da  60a0              STR      r0,[r4,#8]
;;;213        while((pwm->INTSTS & (PWM_INTSTS_DUTY0SYNC_Msk << u32ChannelNum)) == (PWM_INTSTS_DUTY0SYNC_Msk << u32ChannelNum));
0000dc  2210              MOVS     r2,#0x10
0000de  40b2              LSLS     r2,r2,r6
                  |L3.224|
0000e0  6921              LDR      r1,[r4,#0x10]
0000e2  4610              MOV      r0,r2
0000e4  4388              BICS     r0,r0,r1
0000e6  d0fb              BEQ      |L3.224|
;;;214        *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CN_Msk;
0000e8  200c              MOVS     r0,#0xc
0000ea  4346              MULS     r6,r0,r6
0000ec  1930              ADDS     r0,r6,r4
0000ee  69c1              LDR      r1,[r0,#0x1c]
0000f0  0c09              LSRS     r1,r1,#16
0000f2  0409              LSLS     r1,r1,#16
0000f4  61c1              STR      r1,[r0,#0x1c]
;;;215        *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= u16CNR;
0000f6  69c1              LDR      r1,[r0,#0x1c]
0000f8  4339              ORRS     r1,r1,r7
0000fa  61c1              STR      r1,[r0,#0x1c]
;;;216    
;;;217        return(i);
0000fc  4660              MOV      r0,r12
;;;218    }
0000fe  b007              ADD      sp,sp,#0x1c
000100  bdf0              POP      {r4-r7,pc}
                  |L3.258|
000102  2004              MOVS     r0,#4                 ;198
000104  e7d0              B        |L3.168|
                  |L3.262|
000106  2000              MOVS     r0,#0                 ;200
000108  e7ce              B        |L3.168|
                  |L3.266|
00010a  2001              MOVS     r0,#1                 ;202
00010c  e7cc              B        |L3.168|
                  |L3.270|
00010e  2002              MOVS     r0,#2                 ;204
000110  e7ca              B        |L3.168|
;;;219    
                          ENDP

000112  0000              DCW      0x0000
                  |L3.276|
                          DCD      SystemCoreClock
                  |L3.280|
                          DCD      0x0000ffff
                  |L3.284|
                          DCD      0x40040000
                  |L3.288|
                          DCD      0x50000200
                  |L3.292|
                          DCD      0x00b71b00
                  |L3.296|
                          DCD      0x3b9aca00

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;36      */
;;;37     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;38                                       uint32_t u32ChannelNum,
;;;39                                       uint32_t u32Frequency,
;;;40                                       uint32_t u32DutyCycle)
;;;41     {
000002  4604              MOV      r4,r0
;;;42         uint32_t i;
;;;43         uint32_t u32ClkSrc;
;;;44         uint32_t u32PWM_Clock = SystemCoreClock;
000004  4855              LDR      r0,|L4.348|
000006  b083              SUB      sp,sp,#0xc            ;41
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;45         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;46         uint16_t u16CNR = 0xFFFF;
00000a  9000              STR      r0,[sp,#0]
00000c  460f              MOV      r7,r1                 ;41
00000e  4854              LDR      r0,|L4.352|
000010  9001              STR      r0,[sp,#4]            ;41
000012  4694              MOV      r12,r2                ;41
;;;47     
;;;48         if(pwm == PWM0)
;;;49             u32ClkSrc = (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM0_CH01_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL1_PWM0_CH01_S_Pos + (u32ChannelNum & 2));
000014  2102              MOVS     r1,#2
000016  4638              MOV      r0,r7                 ;41
000018  2230              MOVS     r2,#0x30
00001a  4008              ANDS     r0,r0,r1
00001c  4611              MOV      r1,r2
00001e  4b51              LDR      r3,|L4.356|
000020  4081              LSLS     r1,r1,r0
000022  2501              MOVS     r5,#1                 ;45
000024  26ff              MOVS     r6,#0xff              ;45
000026  1d00              ADDS     r0,r0,#4
;;;50     
;;;51         else
;;;52             u32ClkSrc = (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM1_CH01_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL2_PWM1_CH01_S_Pos + (u32ChannelNum & 2));
000028  4a4f              LDR      r2,|L4.360|
00002a  429c              CMP      r4,r3                 ;48
00002c  d101              BNE      |L4.50|
00002e  6952              LDR      r2,[r2,#0x14]         ;49
000030  e000              B        |L4.52|
                  |L4.50|
000032  6992              LDR      r2,[r2,#0x18]
                  |L4.52|
000034  400a              ANDS     r2,r2,r1
000036  40c2              LSRS     r2,r2,r0
;;;53     
;;;54         switch (u32ClkSrc)
;;;55         {
;;;56         case 0:
;;;57             u32PWM_Clock = __HXT;
000038  484c              LDR      r0,|L4.364|
00003a  d008              BEQ      |L4.78|
00003c  2a01              CMP      r2,#1                 ;54
00003e  d004              BEQ      |L4.74|
000040  2a02              CMP      r2,#2                 ;54
000042  d005              BEQ      |L4.80|
000044  2a03              CMP      r2,#3                 ;54
000046  d103              BNE      |L4.80|
000048  e001              B        |L4.78|
                  |L4.74|
;;;58             break;
;;;59         case 1:
;;;60             u32PWM_Clock = __LXT;
00004a  2001              MOVS     r0,#1
00004c  03c0              LSLS     r0,r0,#15
                  |L4.78|
;;;61             break;
;;;62         case 2:
;;;63             u32PWM_Clock = SystemCoreClock;
;;;64             break;
;;;65         case 3:
;;;66             u32PWM_Clock = __HIRC12M;
00004e  9000              STR      r0,[sp,#0]
                  |L4.80|
000050  4661              MOV      r1,r12                ;41
;;;67             break;
;;;68         }
;;;69     
;;;70         for(; u8Divider < 17; u8Divider <<= 1)    // clk divider could only be 1, 2, 4, 8, 16
;;;71         {
;;;72             i = (u32PWM_Clock / u32Frequency) / u8Divider;
000052  9800              LDR      r0,[sp,#0]
000054  f7fffffe          BL       __aeabi_uidivmod
000058  9002              STR      r0,[sp,#8]
                  |L4.90|
00005a  4629              MOV      r1,r5
00005c  f7fffffe          BL       __aeabi_uidivmod
;;;73             // If target value is larger than CNR * prescale, need to use a larger divider
;;;74             if(i > (0x10000 * 0x100))
000060  2101              MOVS     r1,#1
000062  0609              LSLS     r1,r1,#24
000064  4288              CMP      r0,r1
000066  d812              BHI      |L4.142|
;;;75                 continue;
;;;76     
;;;77             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;78             u8Prescale = (i + 0xFFFF)/ 0x10000;
000068  493d              LDR      r1,|L4.352|
00006a  1841              ADDS     r1,r0,r1
00006c  0209              LSLS     r1,r1,#8
00006e  0e0e              LSRS     r6,r1,#24
;;;79     
;;;80             // u8Prescale must at least be 2, otherwise the output stop
;;;81             if(u8Prescale < 3)
000070  2e03              CMP      r6,#3
000072  d200              BCS      |L4.118|
;;;82                 u8Prescale = 2;
000074  2602              MOVS     r6,#2
                  |L4.118|
;;;83     
;;;84             i /= u8Prescale;
000076  4631              MOV      r1,r6
000078  f7fffffe          BL       __aeabi_uidivmod
;;;85     
;;;86             if(i <= 0x10000)
00007c  2101              MOVS     r1,#1
00007e  0409              LSLS     r1,r1,#16
000080  4288              CMP      r0,r1
000082  d804              BHI      |L4.142|
;;;87             {
;;;88                 if(i == 1)
000084  2801              CMP      r0,#1
000086  d000              BEQ      |L4.138|
;;;89                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;90                 else
;;;91                     u16CNR = i;
000088  b280              UXTH     r0,r0
                  |L4.138|
00008a  9001              STR      r0,[sp,#4]            ;89
00008c  e005              B        |L4.154|
                  |L4.142|
00008e  0668              LSLS     r0,r5,#25             ;70
000090  0e05              LSRS     r5,r0,#24             ;70
000092  2d11              CMP      r5,#0x11              ;70
000094  d201              BCS      |L4.154|
000096  9802              LDR      r0,[sp,#8]            ;70
000098  e7df              B        |L4.90|
                  |L4.154|
;;;92                 break;
;;;93             }
;;;94     
;;;95         }
;;;96         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;97         i = u32PWM_Clock / (u8Prescale * u8Divider * u16CNR);
00009a  4631              MOV      r1,r6
00009c  9801              LDR      r0,[sp,#4]
00009e  4369              MULS     r1,r5,r1
0000a0  4341              MULS     r1,r0,r1
0000a2  9800              LDR      r0,[sp,#0]
0000a4  f7fffffe          BL       __aeabi_uidivmod
;;;98     
;;;99         u8Prescale -= 1;
;;;100        u16CNR -= 1;
0000a8  9000              STR      r0,[sp,#0]
0000aa  9801              LDR      r0,[sp,#4]
0000ac  1e76              SUBS     r6,r6,#1              ;97
0000ae  1e40              SUBS     r0,r0,#1
0000b0  b2f2              UXTB     r2,r6                 ;99
0000b2  b286              UXTH     r6,r0
;;;101        // convert to real register value
;;;102        if(u8Divider == 1)
0000b4  2d01              CMP      r5,#1
0000b6  d046              BEQ      |L4.326|
;;;103            u8Divider = 4;
;;;104        else if (u8Divider == 2)
0000b8  2d02              CMP      r5,#2
0000ba  d046              BEQ      |L4.330|
;;;105            u8Divider = 0;
;;;106        else if (u8Divider == 4)
0000bc  2d04              CMP      r5,#4
0000be  d046              BEQ      |L4.334|
;;;107            u8Divider = 1;
;;;108        else if (u8Divider == 8)
0000c0  2d08              CMP      r5,#8
0000c2  d046              BEQ      |L4.338|
;;;109            u8Divider = 2;
;;;110        else // 16
;;;111            u8Divider = 3;
0000c4  2003              MOVS     r0,#3
                  |L4.198|
;;;112    
;;;113        // every two channels share a prescaler
;;;114        while((pwm->INTSTS & PWM_INTSTS_PRESSYNC_Msk ) == PWM_INTSTS_PRESSYNC_Msk);
0000c6  6921              LDR      r1,[r4,#0x10]
0000c8  05c9              LSLS     r1,r1,#23
0000ca  d4fc              BMI      |L4.198|
;;;115        pwm->PRES = (pwm->PRES & ~(PWM_PRES_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
0000cc  6823              LDR      r3,[r4,#0]
0000ce  0879              LSRS     r1,r7,#1
0000d0  00c9              LSLS     r1,r1,#3
0000d2  25ff              MOVS     r5,#0xff
0000d4  408d              LSLS     r5,r5,r1
0000d6  43ab              BICS     r3,r3,r5
0000d8  408a              LSLS     r2,r2,r1
0000da  4313              ORRS     r3,r3,r2
0000dc  6023              STR      r3,[r4,#0]
;;;116        pwm->CLKSEL = (pwm->CLKSEL & ~(PWM_CLKSEL_CLKSEL0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
0000de  6862              LDR      r2,[r4,#4]
0000e0  00b9              LSLS     r1,r7,#2
0000e2  2307              MOVS     r3,#7
0000e4  408b              LSLS     r3,r3,r1
0000e6  439a              BICS     r2,r2,r3
0000e8  4088              LSLS     r0,r0,r1
0000ea  4302              ORRS     r2,r2,r0
0000ec  6062              STR      r2,[r4,#4]
;;;117        pwm->CTL |= (PWM_CTL_CH0MOD_Msk << (u32ChannelNum * 8));
0000ee  68a0              LDR      r0,[r4,#8]
0000f0  00fa              LSLS     r2,r7,#3
0000f2  2108              MOVS     r1,#8
0000f4  4091              LSLS     r1,r1,r2
0000f6  4308              ORRS     r0,r0,r1
0000f8  60a0              STR      r0,[r4,#8]
;;;118        while((pwm->INTSTS & (PWM_INTSTS_DUTY0SYNC_Msk << u32ChannelNum)) == (PWM_INTSTS_DUTY0SYNC_Msk << u32ChannelNum));
0000fa  2210              MOVS     r2,#0x10
0000fc  40ba              LSLS     r2,r2,r7
                  |L4.254|
0000fe  6921              LDR      r1,[r4,#0x10]
000100  4610              MOV      r0,r2
000102  4388              BICS     r0,r0,r1
000104  d0fb              BEQ      |L4.254|
;;;119        if(u32DutyCycle == 0)
;;;120            *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CM_Msk;
000106  210c              MOVS     r1,#0xc
000108  434f              MULS     r7,r1,r7
00010a  9806              LDR      r0,[sp,#0x18]         ;119
00010c  193c              ADDS     r4,r7,r4
00010e  2800              CMP      r0,#0                 ;119
;;;121        else
;;;122        {
;;;123            *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CM_Msk;
000110  69e0              LDR      r0,[r4,#0x1c]
000112  d020              BEQ      |L4.342|
000114  b280              UXTH     r0,r0
000116  61e0              STR      r0,[r4,#0x1c]
;;;124            *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= ((u32DutyCycle * (u16CNR + 1) / 100 - 1) << PWM_DUTY_CM_Pos);
000118  9806              LDR      r0,[sp,#0x18]
00011a  1c71              ADDS     r1,r6,#1
00011c  4348              MULS     r0,r1,r0
00011e  2164              MOVS     r1,#0x64
000120  f7fffffe          BL       __aeabi_uidivmod
000124  0401              LSLS     r1,r0,#16
000126  2001              MOVS     r0,#1
000128  0400              LSLS     r0,r0,#16
00012a  1a08              SUBS     r0,r1,r0
00012c  69e1              LDR      r1,[r4,#0x1c]
00012e  4308              ORRS     r0,r0,r1
                  |L4.304|
000130  61e0              STR      r0,[r4,#0x1c]
;;;125        }
;;;126        *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CN_Msk;
000132  69e0              LDR      r0,[r4,#0x1c]
000134  0c00              LSRS     r0,r0,#16
000136  0400              LSLS     r0,r0,#16
000138  61e0              STR      r0,[r4,#0x1c]
;;;127        *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= u16CNR;
00013a  69e0              LDR      r0,[r4,#0x1c]
00013c  4330              ORRS     r0,r0,r6
00013e  61e0              STR      r0,[r4,#0x1c]
;;;128    
;;;129        return(i);
000140  9800              LDR      r0,[sp,#0]
;;;130    }
000142  b007              ADD      sp,sp,#0x1c
000144  bdf0              POP      {r4-r7,pc}
                  |L4.326|
000146  2004              MOVS     r0,#4                 ;103
000148  e7bd              B        |L4.198|
                  |L4.330|
00014a  2000              MOVS     r0,#0                 ;105
00014c  e7bb              B        |L4.198|
                  |L4.334|
00014e  2001              MOVS     r0,#1                 ;107
000150  e7b9              B        |L4.198|
                  |L4.338|
000152  2002              MOVS     r0,#2                 ;109
000154  e7b7              B        |L4.198|
                  |L4.342|
000156  b280              UXTH     r0,r0                 ;120
000158  e7ea              B        |L4.304|
;;;131    
                          ENDP

00015a  0000              DCW      0x0000
                  |L4.348|
                          DCD      SystemCoreClock
                  |L4.352|
                          DCD      0x0000ffff
                  |L4.356|
                          DCD      0x40040000
                  |L4.360|
                          DCD      0x50000200
                  |L4.364|
                          DCD      0x00b71b00

                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;307     */
;;;308    void PWM_DisableCapture (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b5f0              PUSH     {r4-r7,lr}
;;;309    {
;;;310        uint8_t i;
;;;311        uint32_t u32CTLMask = 0;
000002  2300              MOVS     r3,#0
;;;312        uint32_t u32CAPCTLMask = 0;
000004  461c              MOV      r4,r3
;;;313    
;;;314        for (i = 0; i < PWM_CHANNEL_NUM; i++)
000006  461a              MOV      r2,r3
;;;315        {
;;;316            if ( u32ChannelMask  & (1 << i))
000008  2701              MOVS     r7,#1
                  |L5.10|
00000a  463d              MOV      r5,r7
00000c  4095              LSLS     r5,r5,r2
00000e  420d              TST      r5,r1
000010  d006              BEQ      |L5.32|
;;;317            {
;;;318                u32CTLMask |= (PWM_CTL_CH0EN_Msk << (i * 8));
000012  00d5              LSLS     r5,r2,#3
000014  463e              MOV      r6,r7
000016  40ae              LSLS     r6,r6,r5
000018  4333              ORRS     r3,r3,r6
;;;319                u32CAPCTLMask |= ((PWM_CAPCTL_CAPCH0EN_Msk | PWM_CAPCTL_CAPCH0PADEN_Msk) << (i * 8));
00001a  2606              MOVS     r6,#6
00001c  40ae              LSLS     r6,r6,r5
00001e  4334              ORRS     r4,r4,r6
                  |L5.32|
000020  1c52              ADDS     r2,r2,#1
000022  b2d2              UXTB     r2,r2                 ;314
000024  2a04              CMP      r2,#4                 ;314
000026  d3f0              BCC      |L5.10|
;;;320            }
;;;321        }
;;;322    
;;;323        pwm->CTL &= ~u32CTLMask;
000028  6881              LDR      r1,[r0,#8]
00002a  4399              BICS     r1,r1,r3
00002c  6081              STR      r1,[r0,#8]
;;;324        pwm->CAPCTL &= ~u32CAPCTLMask;
00002e  6d41              LDR      r1,[r0,#0x54]
000030  43a1              BICS     r1,r1,r4
000032  6541              STR      r1,[r0,#0x54]
;;;325    }
000034  bdf0              POP      {r4-r7,pc}
;;;326    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;408     */
;;;409    void PWM_DisableCaptureInt (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  6d83              LDR      r3,[r0,#0x58]
;;;410    {
;;;411        // disable capture interrupt
;;;412        pwm->CAPINTEN &= ~(u32Edge << (u32ChannelNum * 8));
000002  00c9              LSLS     r1,r1,#3
000004  408a              LSLS     r2,r2,r1
000006  4393              BICS     r3,r3,r2
000008  6583              STR      r3,[r0,#0x58]
;;;413    }
00000a  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;374     */
;;;375    void PWM_DisableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6883              LDR      r3,[r0,#8]
;;;376    {
;;;377        // every two channels shares the same setting
;;;378        u32ChannelNum >>= 1;
000002  0849              LSRS     r1,r1,#1
;;;379        // enable dead zone
;;;380        pwm->CTL &= ~(PWM_CTL_DZEN01_Msk << u32ChannelNum);
000004  2210              MOVS     r2,#0x10
000006  408a              LSLS     r2,r2,r1
000008  4393              BICS     r3,r3,r2
00000a  6083              STR      r3,[r0,#8]
;;;381    }
00000c  4770              BX       lr
;;;382    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;345     */
;;;346    void PWM_DisableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
000000  6942              LDR      r2,[r0,#0x14]
;;;347    {
;;;348        pwm->OE &= ~u32ChannelMask;
000002  438a              BICS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;349    }
000006  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.PWM_DisablePDMA||, CODE, READONLY, ALIGN=1

                  PWM_DisablePDMA PROC
;;;522     */
;;;523    void PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum)
000000  2900              CMP      r1,#0
;;;524    {
;;;525        if (u32ChannelNum == 0)
;;;526            pwm->CAPCTL &= ~PWM_CAPCTL_CH0PDMAEN_Msk;
;;;527        else
;;;528            pwm->CAPCTL &= ~PWM_CAPCTL_CH2PDMAEN_Msk;
000002  6d41              LDR      r1,[r0,#0x54]
000004  d004              BEQ      |L9.16|
000006  2201              MOVS     r2,#1
000008  04d2              LSLS     r2,r2,#19
                  |L9.10|
00000a  4391              BICS     r1,r1,r2              ;526
00000c  6541              STR      r1,[r0,#0x54]         ;526
;;;529    }
00000e  4770              BX       lr
                  |L9.16|
000010  2208              MOVS     r2,#8                 ;526
000012  e7fa              B        |L9.10|
;;;530    
                          ENDP


                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;465     */
;;;466    void PWM_DisablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  68c2              LDR      r2,[r0,#0xc]
;;;467    {
;;;468        pwm->INTEN &= ~(PWM_INTEN_TMIE0_Msk << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  60c2              STR      r2,[r0,#0xc]
;;;469    }
00000a  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;284     */
;;;285    void PWM_EnableCapture (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b5f0              PUSH     {r4-r7,lr}
;;;286    {
;;;287        uint8_t i;
;;;288        uint32_t u32Mask = 0;
000002  2300              MOVS     r3,#0
;;;289    
;;;290        for (i = 0; i < PWM_CHANNEL_NUM; i++)
;;;291        {
;;;292            if ( u32ChannelMask  & (1 << i))
000004  2601              MOVS     r6,#1
000006  461a              MOV      r2,r3                 ;290
;;;293            {
;;;294                u32Mask |= ((PWM_CAPCTL_CAPCH0EN_Msk | PWM_CAPCTL_CAPCH0PADEN_Msk) << (i * 8));
000008  2706              MOVS     r7,#6
                  |L11.10|
00000a  4635              MOV      r5,r6                 ;292
00000c  4095              LSLS     r5,r5,r2              ;292
00000e  420d              TST      r5,r1                 ;292
000010  d003              BEQ      |L11.26|
000012  00d5              LSLS     r5,r2,#3
000014  463c              MOV      r4,r7
000016  40ac              LSLS     r4,r4,r5
000018  4323              ORRS     r3,r3,r4
                  |L11.26|
00001a  1c52              ADDS     r2,r2,#1
00001c  b2d2              UXTB     r2,r2                 ;290
00001e  2a04              CMP      r2,#4                 ;290
000020  d3f3              BCC      |L11.10|
;;;295            }
;;;296        }
;;;297    
;;;298        pwm->CAPCTL |= u32Mask;
000022  6d41              LDR      r1,[r0,#0x54]
000024  4319              ORRS     r1,r1,r3
000026  6541              STR      r1,[r0,#0x54]
;;;299    }
000028  bdf0              POP      {r4-r7,pc}
;;;300    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;392     */
;;;393    void PWM_EnableCaptureInt (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  6d83              LDR      r3,[r0,#0x58]
;;;394    {
;;;395        // enable capture interrupt
;;;396        pwm->CAPINTEN |= (u32Edge << (u32ChannelNum * 8));
000002  00c9              LSLS     r1,r1,#3
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6583              STR      r3,[r0,#0x58]
;;;397    }
00000a  4770              BX       lr
;;;398    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;358     */
;;;359    void PWM_EnableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  b530              PUSH     {r4,r5,lr}
;;;360    {
;;;361        // every two channels shares the same setting
;;;362        u32ChannelNum >>= 1;
;;;363        // set duration
;;;364        pwm->PRES = (pwm->PRES & ~(PWM_PRES_DZ01_Msk << (8 * u32ChannelNum))) | ((u32Duration << PWM_PRES_DZ01_Pos ) << (8 * u32ChannelNum));
000002  6804              LDR      r4,[r0,#0]
000004  0849              LSRS     r1,r1,#1              ;362
000006  00cb              LSLS     r3,r1,#3
000008  25ff              MOVS     r5,#0xff
00000a  042d              LSLS     r5,r5,#16
00000c  409d              LSLS     r5,r5,r3
00000e  409a              LSLS     r2,r2,r3
000010  43ac              BICS     r4,r4,r5
000012  0412              LSLS     r2,r2,#16
000014  4314              ORRS     r4,r4,r2
000016  6004              STR      r4,[r0,#0]
;;;365        // enable dead zone
;;;366        pwm->CTL |= (PWM_CTL_DZEN01_Msk << u32ChannelNum);
000018  6882              LDR      r2,[r0,#8]
00001a  2310              MOVS     r3,#0x10
00001c  408b              LSLS     r3,r3,r1
00001e  431a              ORRS     r2,r2,r3
000020  6082              STR      r2,[r0,#8]
;;;367    }
000022  bd30              POP      {r4,r5,pc}
;;;368    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;333     */
;;;334    void PWM_EnableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
000000  6942              LDR      r2,[r0,#0x14]
;;;335    {
;;;336        pwm->OE |= u32ChannelMask;
000002  430a              ORRS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;337    }
000006  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.PWM_EnablePDMA||, CODE, READONLY, ALIGN=2

                  PWM_EnablePDMA PROC
;;;508     */
;;;509    void PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode)
000000  b510              PUSH     {r4,lr}
;;;510    {
;;;511        if (u32ChannelNum == 0)
000002  2900              CMP      r1,#0
;;;512            pwm->CAPCTL = (pwm->CAPCTL & ~(PWM_CAPCTL_PDMACAPMOD0_Msk | PWM_CAPCTL_CH0RFORDER_Msk)) | u32Mode | u32RisingFirst | PWM_CAPCTL_CH0PDMAEN_Msk;
;;;513        else
;;;514            pwm->CAPCTL = (pwm->CAPCTL & ~(PWM_CAPCTL_PDMACAPMOD2_Msk | PWM_CAPCTL_CH2RFORDER_Msk)) | (u32Mode << 16)| (u32RisingFirst << 16)| PWM_CAPCTL_CH2PDMAEN_Msk;
000004  6d41              LDR      r1,[r0,#0x54]
000006  d00a              BEQ      |L15.30|
000008  4c08              LDR      r4,|L15.44|
00000a  041b              LSLS     r3,r3,#16
00000c  4021              ANDS     r1,r1,r4
00000e  4319              ORRS     r1,r1,r3
000010  0412              LSLS     r2,r2,#16
000012  4311              ORRS     r1,r1,r2
000014  2201              MOVS     r2,#1
000016  04d2              LSLS     r2,r2,#19
                  |L15.24|
000018  4311              ORRS     r1,r1,r2              ;512
00001a  6541              STR      r1,[r0,#0x54]         ;512
;;;515    }
00001c  bd10              POP      {r4,pc}
                  |L15.30|
00001e  4c04              LDR      r4,|L15.48|
000020  4021              ANDS     r1,r1,r4              ;512
000022  4319              ORRS     r1,r1,r3              ;512
000024  4311              ORRS     r1,r1,r2              ;512
000026  2208              MOVS     r2,#8                 ;512
000028  e7f6              B        |L15.24|
;;;516    
                          ENDP

00002a  0000              DCW      0x0000
                  |L15.44|
                          DCD      0xefcfffff
                  |L15.48|
                          DCD      0xffffefcf

                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;453     */
;;;454    void PWM_EnablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  68c2              LDR      r2,[r0,#0xc]
;;;455    {
;;;456        // enable period interrupt
;;;457        pwm->INTEN |= (PWM_INTEN_TMIE0_Msk << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  431a              ORRS     r2,r2,r3
000008  60c2              STR      r2,[r0,#0xc]
;;;458    }
00000a  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;267     */
;;;268    void PWM_ForceStop (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;269    {
;;;270        uint32_t i;
;;;271        for (i = 0; i < PWM_CHANNEL_NUM; i++)
000002  2200              MOVS     r2,#0
;;;272        {
;;;273            if ( u32ChannelMask  & (1 << i))
000004  2501              MOVS     r5,#1
                  |L17.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d005              BEQ      |L17.26|
;;;274                pwm->CTL &= ~(PWM_CTL_CH0EN_Msk << (i * 8));
00000e  6884              LDR      r4,[r0,#8]
000010  00d6              LSLS     r6,r2,#3
000012  462b              MOV      r3,r5
000014  40b3              LSLS     r3,r3,r6
000016  439c              BICS     r4,r4,r3
000018  6084              STR      r4,[r0,#8]
                  |L17.26|
00001a  1c52              ADDS     r2,r2,#1
00001c  2a04              CMP      r2,#4                 ;271
00001e  d3f2              BCC      |L17.6|
;;;275        }
;;;276    }
000020  bd70              POP      {r4-r6,pc}
;;;277    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;440     */
;;;441    uint32_t PWM_GetCaptureIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6dc0              LDR      r0,[r0,#0x5c]
;;;442    {
;;;443        return ((pwm->CAPINTSTS >> (u32ChannelNum * 8)) & (PWM_RISING_FALLING_LATCH_INT_FLAG));
000002  00c9              LSLS     r1,r1,#3
000004  40c8              LSRS     r0,r0,r1
000006  2106              MOVS     r1,#6
000008  4008              ANDS     r0,r0,r1
;;;444    }
00000a  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetPeriodIntFlag PROC
;;;490     */
;;;491    uint32_t PWM_GetPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6900              LDR      r0,[r0,#0x10]
;;;492    {
;;;493        return ((pwm->INTSTS & (PWM_INTSTS_TMINT0_Msk << u32ChannelNum)) ? 1 : 0);
000002  2201              MOVS     r2,#1
000004  408a              LSLS     r2,r2,r1
000006  4010              ANDS     r0,r0,r2
000008  d000              BEQ      |L19.12|
00000a  2001              MOVS     r0,#1
                  |L19.12|
;;;494    }
00000c  4770              BX       lr
;;;495    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;226     */
;;;227    void PWM_Start (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
;;;229        uint8_t i;
;;;230        uint32_t u32Mask = 0;
000002  2300              MOVS     r3,#0
;;;231    
;;;232        for (i = 0; i < PWM_CHANNEL_NUM; i++)
000004  461a              MOV      r2,r3
;;;233        {
;;;234            if ( u32ChannelMask  & (1 << i))
000006  2601              MOVS     r6,#1
                  |L20.8|
000008  4635              MOV      r5,r6
00000a  4095              LSLS     r5,r5,r2
00000c  4634              MOV      r4,r6
00000e  420d              TST      r5,r1
000010  d002              BEQ      |L20.24|
;;;235                u32Mask |= (PWM_CTL_CH0EN_Msk << (i * 8));
000012  00d5              LSLS     r5,r2,#3
000014  40ac              LSLS     r4,r4,r5
000016  4323              ORRS     r3,r3,r4
                  |L20.24|
000018  1c52              ADDS     r2,r2,#1
00001a  b2d2              UXTB     r2,r2                 ;232
00001c  2a04              CMP      r2,#4                 ;232
00001e  d3f3              BCC      |L20.8|
;;;236        }
;;;237    
;;;238        pwm->CTL |= u32Mask;
000020  6881              LDR      r1,[r0,#8]
000022  4319              ORRS     r1,r1,r3
000024  6081              STR      r1,[r0,#8]
;;;239    }
000026  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;247     */
;;;248    void PWM_Stop (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;249    {
;;;250        uint32_t i;
;;;251        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;252        {
;;;253            if(u32ChannelMask & (1 << i))
000004  2401              MOVS     r4,#1
                  |L21.6|
000006  4623              MOV      r3,r4
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L21.28|
;;;254            {
;;;255                *(__IO uint32_t *) (&pwm->DUTY0 + 3 * i) &= ~PWM_DUTY_CN_Msk;
00000e  230c              MOVS     r3,#0xc
000010  4353              MULS     r3,r2,r3
000012  181b              ADDS     r3,r3,r0
000014  69dd              LDR      r5,[r3,#0x1c]
000016  0c2d              LSRS     r5,r5,#16
000018  042d              LSLS     r5,r5,#16
00001a  61dd              STR      r5,[r3,#0x1c]
                  |L21.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a04              CMP      r2,#4                 ;251
000020  d3f1              BCC      |L21.6|
;;;256            }
;;;257        }
;;;258    
;;;259    }
000022  bd30              POP      {r4,r5,pc}
;;;260    
                          ENDP


                          AREA ||i.__ARM_common_ll_mulss||, COMGROUP=__ARM_common_ll_mulss, CODE, READONLY, ALIGN=1

                  __ARM_common_ll_mulss PROC
000000  b5f8              PUSH     {r3-r7,lr}
000002  1404              ASRS     r4,r0,#16
000004  b28b              UXTH     r3,r1
000006  4626              MOV      r6,r4
000008  b282              UXTH     r2,r0
00000a  435e              MULS     r6,r3,r6
00000c  140d              ASRS     r5,r1,#16
00000e  4610              MOV      r0,r2
000010  1437              ASRS     r7,r6,#16
000012  4358              MULS     r0,r3,r0
000014  0436              LSLS     r6,r6,#16
000016  1980              ADDS     r0,r0,r6
000018  2100              MOVS     r1,#0
00001a  4179              ADCS     r1,r1,r7
00001c  4616              MOV      r6,r2
00001e  436e              MULS     r6,r5,r6
000020  1437              ASRS     r7,r6,#16
000022  0436              LSLS     r6,r6,#16
000024  1980              ADDS     r0,r0,r6
000026  4179              ADCS     r1,r1,r7
000028  4626              MOV      r6,r4
00002a  436e              MULS     r6,r5,r6
00002c  1989              ADDS     r1,r1,r6
00002e  bdf8              POP      {r3-r7,pc}
                          ENDP


                          AREA ||i.__ARM_common_ll_muluu||, COMGROUP=__ARM_common_ll_muluu, CODE, READONLY, ALIGN=1

                  __ARM_common_ll_muluu PROC
000000  b5f8              PUSH     {r3-r7,lr}
000002  0c04              LSRS     r4,r0,#16
000004  b28b              UXTH     r3,r1
000006  4626              MOV      r6,r4
000008  b282              UXTH     r2,r0
00000a  435e              MULS     r6,r3,r6
00000c  0c0d              LSRS     r5,r1,#16
00000e  4610              MOV      r0,r2
000010  0c37              LSRS     r7,r6,#16
000012  4358              MULS     r0,r3,r0
000014  0436              LSLS     r6,r6,#16
000016  1980              ADDS     r0,r0,r6
000018  2100              MOVS     r1,#0
00001a  4179              ADCS     r1,r1,r7
00001c  4616              MOV      r6,r2
00001e  436e              MULS     r6,r5,r6
000020  0c37              LSRS     r7,r6,#16
000022  0436              LSLS     r6,r6,#16
000024  1980              ADDS     r0,r0,r6
000026  4179              ADCS     r1,r1,r7
000028  4626              MOV      r6,r4
00002a  436e              MULS     r6,r5,r6
00002c  1989              ADDS     r1,r1,r6
00002e  bdf8              POP      {r3-r7,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REV16|
#line 388 "..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_pwm_c_03ee09af____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REVSH|
#line 402
|__asm___5_pwm_c_03ee09af____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
