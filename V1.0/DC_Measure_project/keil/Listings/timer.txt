; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\Library\StdDriver\inc -I..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\Library\CMSIS\Include -I..\bsp\bus\inc -I..\bsp\devices\inc -I..\User\inc -I.\RTE\_DC_Measure -ID:\software\tools\Keil_v5\Nuvoton\NuMicro_DFP\1.3.12\Device\NANO100BN\Include -ID:\software\tools\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=530 -D_RTE_ --omf_browse=.\objects\timer.crf ..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;78       */
;;;79     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;80     {
;;;81         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;82         timer->IER = 0;
000004  60c1              STR      r1,[r0,#0xc]
;;;83     }
000006  4770              BX       lr
;;;84     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;92       */
;;;93     void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;94     {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
;;;95         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4604              MOV      r4,r0
;;;96         uint32_t u32Prescale = 0, delay = SystemCoreClock / u32Clk;
00000c  4601              MOV      r1,r0
00000e  481d              LDR      r0,|L2.132|
000010  2700              MOVS     r7,#0
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  f7fffffe          BL       __aeabi_uidivmod
000018  4605              MOV      r5,r0
;;;97         long long u64Cmpr;
;;;98     
;;;99         // Clear current timer configuration
;;;100        timer->CTL = 0;
00001a  2000              MOVS     r0,#0
00001c  6030              STR      r0,[r6,#0]
;;;101    
;;;102        if(u32Clk == 10000)           // min delay is 100us if timer clock source is LIRC 10k
00001e  481a              LDR      r0,|L2.136|
000020  4284              CMP      r4,r0
000022  d106              BNE      |L2.50|
;;;103        {
;;;104            u32Usec = ((u32Usec + 99) / 100) * 100;
000024  9802              LDR      r0,[sp,#8]
000026  2164              MOVS     r1,#0x64
000028  3063              ADDS     r0,r0,#0x63
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  2164              MOVS     r1,#0x64
000030  e005              B        |L2.62|
                  |L2.50|
;;;105        }
;;;106        else        // 10 usec every step
;;;107        {
;;;108            u32Usec = ((u32Usec + 9) / 10) * 10;
000032  9802              LDR      r0,[sp,#8]
000034  210a              MOVS     r1,#0xa
000036  3009              ADDS     r0,r0,#9
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  210a              MOVS     r1,#0xa
                  |L2.62|
00003e  4348              MULS     r0,r1,r0
;;;109        }
;;;110    
;;;111        if(u32Clk >= 0x2000000)
000040  2101              MOVS     r1,#1
000042  0649              LSLS     r1,r1,#25
000044  428c              CMP      r4,r1
000046  d302              BCC      |L2.78|
;;;112        {
;;;113            u32Prescale = 3;    // real prescaler value is 4
000048  2703              MOVS     r7,#3
;;;114            u32Clk >>= 2;
00004a  08a4              LSRS     r4,r4,#2
00004c  e005              B        |L2.90|
                  |L2.78|
;;;115        }
;;;116        else if(u32Clk >= 0x1000000)
00004e  2101              MOVS     r1,#1
000050  0609              LSLS     r1,r1,#24
000052  428c              CMP      r4,r1
000054  d301              BCC      |L2.90|
;;;117        {
;;;118            u32Prescale = 1;    // real prescaler value is 2
000056  2701              MOVS     r7,#1
;;;119            u32Clk >>= 1;
000058  0864              LSRS     r4,r4,#1
                  |L2.90|
;;;120        }
;;;121    
;;;122        // u32Usec * u32Clk might overflow if using uint32_t
;;;123        u64Cmpr = ((long long)u32Usec * (long long)u32Clk) / (long long)1000000;
00005a  4621              MOV      r1,r4
00005c  f7fffffe          BL       __ARM_common_ll_muluu
000060  4a0a              LDR      r2,|L2.140|
000062  2300              MOVS     r3,#0
000064  f7fffffe          BL       __aeabi_ldivmod
;;;124    
;;;125        timer->CMPR = (uint32_t)u64Cmpr;
000068  60b0              STR      r0,[r6,#8]
;;;126        timer->PRECNT = u32Prescale;
00006a  6077              STR      r7,[r6,#4]
;;;127        timer->CTL = TIMER_CTL_TMR_EN_Msk; // one shot mode
00006c  2001              MOVS     r0,#1
00006e  6030              STR      r0,[r6,#0]
;;;128    
;;;129        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;130        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;131        for(; delay > 0; delay--)
000070  2d00              CMP      r5,#0
000072  d002              BEQ      |L2.122|
                  |L2.116|
;;;132        {
;;;133            __NOP();
000074  bf00              NOP      
000076  1e6d              SUBS     r5,r5,#1
000078  d1fc              BNE      |L2.116|
                  |L2.122|
;;;134        }
;;;135    
;;;136        while(timer->CTL & TIMER_CTL_TMR_ACT_Msk);
00007a  6830              LDR      r0,[r6,#0]
00007c  0600              LSLS     r0,r0,#24
00007e  d4fc              BMI      |L2.122|
;;;137    
;;;138    }
000080  bdfe              POP      {r1-r7,pc}
;;;139    
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      SystemCoreClock
                  |L2.136|
                          DCD      0x00002710
                  |L2.140|
                          DCD      0x000f4240

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;168      */
;;;169    void TIMER_DisableCapture(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171        timer->CTL &= ~TIMER_CTL_TCAP_EN_Msk;
000002  2201              MOVS     r2,#1
000004  0412              LSLS     r2,r2,#16
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;172    
;;;173    }
00000a  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;194      */
;;;195    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;196    {
;;;197        timer->CTL &= ~TIMER_CTL_EVENT_EN_Msk;
000002  2201              MOVS     r2,#1
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;198    }
00000a  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;259      */
;;;260    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;261    {
;;;262        timer->CTL &= ~TIMER_CTL_INTR_TRG_EN_Msk;
000002  2201              MOVS     r2,#1
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;263    }
00000a  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;154      */
;;;155    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;156    {
;;;157    
;;;158        timer->CTL = (timer->CTL & ~(TIMER_CTL_TCAP_MODE_Msk |
000002  6803              LDR      r3,[r0,#0]
000004  240f              MOVS     r4,#0xf
000006  0464              LSLS     r4,r4,#17
000008  43a3              BICS     r3,r3,r4
00000a  430b              ORRS     r3,r3,r1
00000c  2101              MOVS     r1,#1
00000e  4313              ORRS     r3,r3,r2
000010  0409              LSLS     r1,r1,#16
000012  430b              ORRS     r3,r3,r1
000014  6003              STR      r3,[r0,#0]
;;;159                                     TIMER_CTL_TCAP_CNT_MODE_Msk |
;;;160                                     TIMER_CTL_TCAP_EDGE_Msk)) |
;;;161                     u32CapMode | u32Edge | TIMER_CTL_TCAP_EN_Msk;
;;;162    }
000016  bd10              POP      {r4,pc}
;;;163    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;183      */
;;;184    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6802              LDR      r2,[r0,#0]
;;;185    {
;;;186        timer->CTL = (timer->CTL & ~TIMER_CTL_EVENT_EDGE_Msk) | u32Edge;
000002  2301              MOVS     r3,#1
000004  035b              LSLS     r3,r3,#13
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;187        timer->CTL |= TIMER_CTL_EVENT_EN_Msk;
00000c  6801              LDR      r1,[r0,#0]
00000e  105a              ASRS     r2,r3,#1
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;188    }
000014  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;239      */
;;;240    void TIMER_EnableFreqCounter(TIMER_T *timer,
000000  4908              LDR      r1,|L8.36|
;;;241                                 uint32_t u32DropCount,
;;;242                                 uint32_t u32Timeout,
;;;243                                 uint32_t u32EnableInt)
;;;244    {
;;;245        TIMER_T *t;    // store the timer base to configure compare value
;;;246    
;;;247        t = (timer == TIMER0) ? TIMER1 : TIMER3;
000002  4288              CMP      r0,r1
000004  d101              BNE      |L8.10|
000006  4908              LDR      r1,|L8.40|
000008  e000              B        |L8.12|
                  |L8.10|
00000a  4908              LDR      r1,|L8.44|
                  |L8.12|
;;;248    
;;;249        t->CMPR = 0xFFFFFF;
00000c  4a08              LDR      r2,|L8.48|
00000e  608a              STR      r2,[r1,#8]
;;;250        t->IER = u32EnableInt ? TIMER_IER_TCAP_IE_Msk : 0;
000010  2b00              CMP      r3,#0
000012  d001              BEQ      |L8.24|
000014  2202              MOVS     r2,#2
000016  e000              B        |L8.26|
                  |L8.24|
000018  2200              MOVS     r2,#0
                  |L8.26|
00001a  60ca              STR      r2,[r1,#0xc]
;;;251        timer->CTL = TIMER_CTL_INTR_TRG_EN_Msk | TIMER_CTL_TMR_EN_Msk;
00001c  4904              LDR      r1,|L8.48|
00001e  1c89              ADDS     r1,r1,#2
000020  6001              STR      r1,[r0,#0]
;;;252    
;;;253        return;
;;;254    }
000022  4770              BX       lr
;;;255    /**
                          ENDP

                  |L8.36|
                          DCD      0x40010000
                  |L8.40|
                          DCD      0x40010100
                  |L8.44|
                          DCD      0x40110100
                  |L8.48|
                          DCD      0x00ffffff

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;205      */
;;;206    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b51f              PUSH     {r0-r4,lr}
;;;207    {
;;;208        uint32_t u32Src;
;;;209        const uint32_t au32Clk[] = {__HXT, __LXT, __LIRC, 0};   // we don't know actual clock if external pin is clock source, set to 0 here
000002  4910              LDR      r1,|L9.68|
000004  c91e              LDM      r1,{r1-r4}
;;;210    
;;;211        if(timer == TIMER0)
000006  9403              STR      r4,[sp,#0xc]
000008  466c              MOV      r4,sp
00000a  c40e              STM      r4!,{r1-r3}
00000c  4a0e              LDR      r2,|L9.72|
;;;212            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0_S_Msk) >> CLK_CLKSEL1_TMR0_S_Pos;
00000e  490f              LDR      r1,|L9.76|
000010  4290              CMP      r0,r2                 ;211
000012  d102              BNE      |L9.26|
000014  6948              LDR      r0,[r1,#0x14]
                  |L9.22|
;;;213        else if(timer == TIMER1)
;;;214            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1_S_Msk) >> CLK_CLKSEL1_TMR1_S_Pos;
;;;215        else if(timer == TIMER2)
;;;216            u32Src = (CLK->CLKSEL2 & CLK_CLKSEL2_TMR2_S_Msk) >> CLK_CLKSEL2_TMR2_S_Pos;
;;;217        else // Timer 3
;;;218            u32Src = (CLK->CLKSEL2 & CLK_CLKSEL2_TMR3_S_Msk) >> CLK_CLKSEL2_TMR3_S_Pos;
;;;219    
;;;220        if(u32Src < 4)
;;;221            return au32Clk[u32Src];
;;;222        else
;;;223            return __HIRC;
;;;224    
;;;225    }
000016  0a00              LSRS     r0,r0,#8
000018  e004              B        |L9.36|
                  |L9.26|
00001a  4a0d              LDR      r2,|L9.80|
00001c  4290              CMP      r0,r2                 ;213
00001e  d10a              BNE      |L9.54|
000020  6948              LDR      r0,[r1,#0x14]         ;214
                  |L9.34|
000022  0b00              LSRS     r0,r0,#12
                  |L9.36|
000024  0740              LSLS     r0,r0,#29
000026  0f40              LSRS     r0,r0,#29
000028  2804              CMP      r0,#4                 ;220
00002a  d209              BCS      |L9.64|
00002c  0080              LSLS     r0,r0,#2              ;221
00002e  4669              MOV      r1,sp                 ;221
000030  5808              LDR      r0,[r1,r0]            ;221
                  |L9.50|
000032  b004              ADD      sp,sp,#0x10
000034  bd10              POP      {r4,pc}
                  |L9.54|
000036  4a07              LDR      r2,|L9.84|
000038  4290              CMP      r0,r2                 ;215
00003a  6988              LDR      r0,[r1,#0x18]         ;218
00003c  d0eb              BEQ      |L9.22|
00003e  e7f0              B        |L9.34|
                  |L9.64|
000040  4805              LDR      r0,|L9.88|
000042  e7f6              B        |L9.50|
;;;226    
                          ENDP

                  |L9.68|
                          DCD      ||.constdata||
                  |L9.72|
                          DCD      0x40010000
                  |L9.76|
                          DCD      0x50000200
                  |L9.80|
                          DCD      0x40010100
                  |L9.84|
                          DCD      0x40110000
                  |L9.88|
                          DCD      0x00b71b00

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;41       */
;;;42     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;43     {
000002  4617              MOV      r7,r2
000004  4606              MOV      r6,r0
;;;44         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4604              MOV      r4,r0
;;;45         uint32_t u32Cmpr = 0, u32Prescale = 0;
00000c  2500              MOVS     r5,#0
;;;46     
;;;47         // Fastest possible timer working freq is u32Clk / 2. While cmpr = 2, pre-scale = 0
;;;48         if(u32Freq > (u32Clk / 2))
00000e  0840              LSRS     r0,r0,#1
000010  42b8              CMP      r0,r7
000012  d201              BCS      |L10.24|
;;;49         {
;;;50             u32Cmpr = 2;
000014  2002              MOVS     r0,#2
000016  e010              B        |L10.58|
                  |L10.24|
;;;51         }
;;;52         else
;;;53         {
;;;54             if(u32Clk >= 0x2000000)
000018  2101              MOVS     r1,#1
00001a  0649              LSLS     r1,r1,#25
00001c  428c              CMP      r4,r1
00001e  d302              BCC      |L10.38|
;;;55             {
;;;56                 u32Prescale = 3;    // real prescaler value is 4
000020  2503              MOVS     r5,#3
;;;57                 u32Clk >>= 2;
000022  08a4              LSRS     r4,r4,#2
000024  e005              B        |L10.50|
                  |L10.38|
;;;58             }
;;;59             else if(u32Clk >= 0x1000000)
000026  2101              MOVS     r1,#1
000028  0609              LSLS     r1,r1,#24
00002a  428c              CMP      r4,r1
00002c  d301              BCC      |L10.50|
;;;60             {
;;;61                 u32Prescale = 1;    // real prescaler value is 2
00002e  2501              MOVS     r5,#1
;;;62                 u32Clk >>= 1;
000030  4604              MOV      r4,r0
                  |L10.50|
;;;63             }
;;;64             u32Cmpr = u32Clk / u32Freq;
000032  4639              MOV      r1,r7
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       __aeabi_uidivmod
                  |L10.58|
;;;65         }
;;;66         timer->CMPR = u32Cmpr;
00003a  60b0              STR      r0,[r6,#8]
;;;67         timer->PRECNT = u32Prescale;
00003c  6075              STR      r5,[r6,#4]
;;;68         timer->CTL = u32Mode;
00003e  9901              LDR      r1,[sp,#4]
000040  6031              STR      r1,[r6,#0]
000042  1c6d              ADDS     r5,r5,#1
;;;69     
;;;70     
;;;71         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000044  4368              MULS     r0,r5,r0
000046  4601              MOV      r1,r0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       __aeabi_uidivmod
;;;72     }
00004e  bdfe              POP      {r1-r7,pc}
;;;73     
                          ENDP


                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;272      */
;;;273    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  6802              LDR      r2,[r0,#0]
;;;274    {
;;;275        timer->CTL = (timer->CTL & ~TIMER_CTL_CAP_TRG_EN_Msk) | u32Src;
000002  2301              MOVS     r3,#1
000004  02db              LSLS     r3,r3,#11
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;276    }
00000c  4770              BX       lr
;;;277    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerTarget PROC
;;;286      */
;;;287    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;288    {
;;;289        timer->CTL = (timer->CTL & ~(TIMER_CTL_PDMA_TEEN_Msk | TIMER_CTL_DAC_TEEN_Msk | TIMER_CTL_ADC_TEEN_Msk)) | u32Mask;
000002  2307              MOVS     r3,#7
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;290    }
00000c  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00002710
                          DCD      0x00000000

                          AREA ||i.__ARM_common_ll_muluu||, COMGROUP=__ARM_common_ll_muluu, CODE, READONLY, ALIGN=1

                  __ARM_common_ll_muluu PROC
000000  b5f8              PUSH     {r3-r7,lr}
000002  0c04              LSRS     r4,r0,#16
000004  b28b              UXTH     r3,r1
000006  4626              MOV      r6,r4
000008  b282              UXTH     r2,r0
00000a  435e              MULS     r6,r3,r6
00000c  0c0d              LSRS     r5,r1,#16
00000e  4610              MOV      r0,r2
000010  0c37              LSRS     r7,r6,#16
000012  4358              MULS     r0,r3,r0
000014  0436              LSLS     r6,r6,#16
000016  1980              ADDS     r0,r0,r6
000018  2100              MOVS     r1,#0
00001a  4179              ADCS     r1,r1,r7
00001c  4616              MOV      r6,r2
00001e  436e              MULS     r6,r5,r6
000020  0c37              LSRS     r7,r6,#16
000022  0436              LSLS     r6,r6,#16
000024  1980              ADDS     r0,r0,r6
000026  4179              ADCS     r1,r1,r7
000028  4626              MOV      r6,r4
00002a  436e              MULS     r6,r5,r6
00002c  1989              ADDS     r1,r1,r6
00002e  bdf8              POP      {r3-r7,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
